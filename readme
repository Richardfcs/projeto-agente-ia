# Projeto Agente de IA - Backend

Este √© o reposit√≥rio do backend para o projeto Agente de IA. A aplica√ß√£o √© constru√≠da com Flask e utiliza o MongoDB como banco de dados, Celery para processamento ass√≠ncrono e a API do Google Gemini para as funcionalidades de intelig√™ncia artificial.

## Pr√©-requisitos

Antes de come√ßar, garanta que voc√™ tenha os seguintes softwares instalados em sua m√°quina:

- **Python** (vers√£o 3.10 ou superior)
- **Pip** (gerenciador de pacotes do Python)
- **Git** (para clonar o reposit√≥rio)
- **MongoDB** (uma inst√¢ncia local ou uma conta no [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) para obter a string de conex√£o)
- **Redis** (necess√°rio para o Celery. A forma mais f√°cil de instalar localmente √© via [Docker](https://www.docker.com/))

## ‚öôÔ∏è Instala√ß√£o e Configura√ß√£o

Siga os passos abaixo para configurar o ambiente de desenvolvimento local.

### 1. Clonar o Reposit√≥rio

Abra seu terminal e clone o projeto:

```bash
git clone https://sua-url-do-repositorio.git
cd projeto-agente-ia
```
2. Criar e Ativar o Ambiente Virtual

√â uma boa pr√°tica isolar as depend√™ncias do projeto em um ambiente virtual.

Para macOS / Linux:
```bash
python3 -m venv venv
source venv/bin/activate
```
Para Windows:
```bash
python -m venv venv
.\venv\Scripts\activate
```

3. Instalar as Depend√™ncias

Com o ambiente virtual ativado, instale todas as bibliotecas necess√°rias com um √∫nico comando:

```bash
pip install -r requirements.txt
```

4. Configurar as Vari√°veis de Ambiente

Este √© o passo mais importante. As chaves de API e outras configura√ß√µes sens√≠veis s√£o gerenciadas atrav√©s de um arquivo .env.

a. Crie um arquivo chamado .env na raiz do projeto.

b. Copie o conte√∫do abaixo para dentro do seu arquivo .env e preencha com suas pr√≥prias chaves e configura√ß√µes:

# Arquivo: .env
# Preencha com suas pr√≥prias chaves e configura√ß√µes
```python
# Configura√ß√£o da Aplica√ß√£o Flask
FLASK_ENV=development
SECRET_KEY='coloque-aqui-uma-chave-secreta-bem-longa-e-aleatoria'

# Conex√£o com o Banco de Dados MongoDB
MONGO_URI='sua-string-de-conexao-do-mongodb-aqui'

# Conex√£o com o Broker de Mensagens para Celery
REDIS_URL='redis://localhost:6379/0'

# Chave da API do Google Gemini
GOOGLE_API_KEY='sua-chave-da-api-do-google-aqui'
```

üö® IMPORTANTE: O arquivo .env cont√©m informa√ß√µes sens√≠veis. Ele j√° est√° inclu√≠do no .gitignore e NUNCA deve ser enviado para o reposit√≥rio no GitHub.

‚ñ∂Ô∏è Executando a Aplica√ß√£o

Para rodar o projeto, voc√™ precisar√° de dois terminais abertos, ambos com o ambiente virtual ativado.

1. Iniciar o Servidor Flask

No primeiro terminal, inicie a aplica√ß√£o web:

```bash
python run.py
```

O servidor estar√° dispon√≠vel em http://127.0.0.1:5000. Voc√™ pode testar se ele est√° funcionando acessando http://127.0.0.1:5000/health no seu navegador.

2. Iniciar o Worker do Celery

As tarefas de IA s√£o processadas em segundo plano. Para isso, precisamos de um "worker" do Celery escutando por novas tarefas.

No segundo terminal, execute o seguinte comando:

# NOTA: Este comando ser√° finalizado quando a estrutura do Celery for implementada
```bash
celery -A sua_instancia_celery_aqui worker --loglevel=info
```

(Nota: O comando exato do Celery ser√° definido quando a Se√ß√£o 4 for implementada, mas a estrutura ser√° essa.)

```
üìÇ Estrutura do Projeto
/projeto-agente-ia/
‚îú‚îÄ‚îÄ .env                  # Armazena as vari√°veis de ambiente (secreto)
‚îú‚îÄ‚îÄ requirements.txt      # Lista de depend√™ncias Python
‚îú‚îÄ‚îÄ run.py                # Ponto de entrada para iniciar a aplica√ß√£o
‚îî‚îÄ‚îÄ /src/
    ‚îú‚îÄ‚îÄ __init__.py         # Application Factory (cria a app Flask)
    ‚îú‚îÄ‚îÄ config.py           # Carrega as configura√ß√µes do .env
    ‚îú‚îÄ‚îÄ /api/               # M√≥dulos de endpoints (Blueprints)
    ‚îú‚îÄ‚îÄ /db/                # L√≥gica de conex√£o com o banco de dados
    ‚îî‚îÄ‚îÄ /tasks/             # Tarefas ass√≠ncronas para o Celery (IA, etc.)
```

# Projeto Agente de IA - Checklist de Desenvolvimento (Backend)

Este documento rastreia o progresso do desenvolvimento do backend. Marque as caixas conforme as tarefas forem conclu√≠das.

---

### Se√ß√£o 1: Funda√ß√£o do Projeto (Setup Inicial)

**Objetivo:** Criar um esqueleto de aplica√ß√£o Flask funcional, organizado e pronto para escalar.

- [x] **1.1. Estrutura de Pastas:** Estrutura base com `src`, `api`, `db`, `tasks` est√° criada.
- [x] **1.2. Gerenciamento de Depend√™ncias:** Arquivo `requirements.txt` foi atualizado para remover Celery/Redis e usar Flask.
- [x] **1.3. Configura√ß√£o de Ambiente:** Arquivo `.env` foi criado e o `.gitignore` est√° configurado para ignor√°-lo.
- [x] **1.4. Application Factory:** A fun√ß√£o `create_app` em `src/__init__.py` monta a aplica√ß√£o Flask corretamente, sem a configura√ß√£o do Celery.
- [x] **1.5. Conex√£o com Banco de Dados:** A aplica√ß√£o conecta-se com sucesso ao MongoDB na inicializa√ß√£o.
- [x] **1.6. Valida√ß√£o do Setup:** O endpoint `GET /health` est√° funcionando e retorna uma mensagem de sucesso.

---

### Se√ß√£o 2: M√≥dulo de Autentica√ß√£o e Usu√°rios

**Objetivo:** Implementar um sistema seguro de registro e login usando JWT.

- [x] **2.1. Modelo de Dados:** A cole√ß√£o `users` est√° sendo utilizada para armazenar `username` e `hashed_password`.
- [x] **2.2. Fun√ß√µes de Criptografia:** Fun√ß√µes para criar e verificar hashes de senha com `passlib` est√£o implementadas.
- [x] **2.3. Endpoint de Registro (`POST /api/auth/register`):**
    - [x] Recebe `username` e `password`.
    - [x] Verifica se o usu√°rio j√° existe.
    - [x] Salva o novo usu√°rio com a senha criptografada.
    - [x] Retorna status `201 Created` em caso de sucesso.
- [x] **2.4. Endpoint de Login (`POST /api/auth/login`):**
    - [x] Recebe `username` e `password`.
    - [x] Valida as credenciais contra os dados no banco.
    - [x] Gera e retorna um `access_token` JWT em caso de sucesso.
- [x] **2.5. Endpoint de Perfil (`GET /api/auth/profile`):**
    - [x] A rota est√° protegida e requer um token JWT v√°lido.
    - [x] Extrai a identidade do usu√°rio a partir do token.
    - [x] Retorna os dados do usu√°rio logado (sem a senha).

---

### Se√ß√£o 3: Gerenciamento de Arquivos com GridFS

**Objetivo:** Criar endpoints para upload e download de arquivos grandes.

- [x] **3.1. Modelos de Dados:** As cole√ß√µes `templates` e `documents` s√£o utilizadas para armazenar os metadados dos arquivos.
- [x] **3.2. Endpoint de Upload de Template (`POST /api/templates/upload`):** Rota implementada e funcional.
- [x] **3.3. Endpoint de Upload de Documento (`POST /api/documents/upload`):** Rota implementada e funcional.
- [x] **3.4. Endpoint de Download (`GET /api/files/<gridfs_file_id>`):**
    - [x] A rota est√° protegida.
    - [x] Verifica a permiss√£o do usu√°rio para acessar o arquivo.
    - [x] Busca o arquivo no GridFS e o retorna para download.

---

### Se√ß√£o 4: M√≥dulo Conversacional e Processamento de IA (S√≠ncrono)

**Objetivo:** Implementar o fluxo de chat onde a API aguarda a conclus√£o do processamento de IA.

- [x] **4.1. Modelos de Dados:** As estruturas das cole√ß√µes `conversations` e `messages` est√£o definidas e sendo utilizadas.
- [x] **4.2. Endpoint de Nova Mensagem (`POST /api/chat/conversations`):**
    - [x] A rota est√° protegida e funcional.
    - [x] Cria/atualiza os documentos nas cole√ß√µes `conversations` e `messages`.
    - [x] **Chama a fun√ß√£o de processamento de IA (`processar_solicitacao_ia`) diretamente.**
    - [x] **Aguarda a conclus√£o da tarefa de IA antes de responder.**
    - [x] Retorna uma resposta (`201 Created` ou `500 Server Error`) ap√≥s o processamento.
- [x] **4.3. Endpoints de Hist√≥rico:**
    - [x] `GET /api/chat/conversations`: Lista todas as conversas do usu√°rio logado.
    - [x] `GET /api/chat/conversations/<conversation_id>`: Lista todas as mensagens de uma conversa espec√≠fica.
- [x] **4.4. Fun√ß√£o de Processamento de IA (`processar_solicitacao_ia`):**
    - [x] √â uma fun√ß√£o Python padr√£o (n√£o mais uma tarefa Celery).
    - [x] Busca o hist√≥rico e os arquivos necess√°rios do MongoDB/GridFS.
    - [x] Interage com a API do Gemini.
    - [x] Cria os arquivos de sa√≠da em mem√≥ria (streams).
    - [x] Salva os arquivos de sa√≠da no GridFS e cria seus metadados.
    - [x] Cria a mensagem de resposta do assistente na cole√ß√£o `messages`.
    - [x] Retorna um status de sucesso ou falha para a rota da API.
    
---

### **Pr√≥ximos Passos Funcionais para o Backend**

#### **Prioridade 1: Dar "Mem√≥ria" √† IA**

**Objetivo:** Fazer com que a IA entenda o contexto da conversa, permitindo intera√ß√µes de acompanhamento.

-   **[ ] 1.1. Modificar a Tarefa de IA (`processar_solicitacao_ia`):**
    -   Antes de chamar a API do Gemini, a fun√ß√£o deve buscar **todas as mensagens anteriores** da `conversation_id` atual no MongoDB.
    -   Formatar o hist√≥rico de mensagens em um formato que o Gemini entenda (geralmente uma lista de objetos com `role` e `content`).
    -   Enviar o hist√≥rico completo junto com o novo prompt do usu√°rio para a API do Gemini.

---

#### **Prioridade 2: Ativar a Intera√ß√£o com Arquivos**

**Objetivo:** Permitir que a IA leia o conte√∫do dos arquivos que os usu√°rios enviam e use os templates para gerar documentos formatados.

-   **[ ] 2.1. Criar "Ferramentas" de Leitura de Arquivos:**
    -   Desenvolver uma fun√ß√£o (`read_docx_from_gridfs`) que, dado um `file_id`, busca o arquivo `.docx` no GridFS e extrai seu texto.
    -   Desenvolver uma fun√ß√£o (`read_xlsx_from_gridfs`) que usa a biblioteca `pandas` para ler um arquivo `.xlsx` do GridFS e convert√™-lo em um formato √∫til para a IA (como JSON ou Markdown).

-   **[ ] 2.2. Habilitar o Uso de Templates (com `docxtpl`):**
    -   Modificar a tarefa de IA para que, se o prompt do usu√°rio mencionar um template, ela:
        1.  Busque o arquivo do template (`.docx` com campos `{{ variavel }}`) do GridFS.
        2.  Use a resposta do Gemini para criar um dicion√°rio de "contexto" (ex: `{"nome_cliente": "Empresa X", ...}`).
        3.  Use a biblioteca `docxtpl` para renderizar o template com o contexto, gerando o documento final preenchido.

-   **[ ] 2.3. Atualizar a Rota de Mensagens:**
    -   Modificar o endpoint `POST /api/chat/conversations` para que ele possa receber, opcionalmente, um `input_document_id` junto com o prompt.
    -   Salvar este ID na mensagem do usu√°rio na cole√ß√£o `messages` para que a tarefa de IA saiba qual arquivo ler.

---

#### **Prioridade 3: Aumentar a Flexibilidade e o Controle do Usu√°rio**

**Objetivo:** Dar ao usu√°rio mais controle sobre o resultado gerado.

-   **[ ] 3.1. Gera√ß√£o de Arquivos Din√¢mica:**
    -   Modificar a tarefa de IA para que ela analise o prompt do usu√°rio em busca de palavras-chave como "crie um PDF", "gere uma planilha" ou "fa√ßa um documento Word".
    -   Com base nessa an√°lise, a tarefa deve chamar a fun√ß√£o de cria√ß√£o de stream correta (`criar_pdf_stream`, `criar_xlsx_stream`, etc.).

-   **[ ] 3.2. Nomea√ß√£o de Arquivos Inteligente:**
    -   Implementar uma l√≥gica (possivelmente usando a pr√≥pria IA) para gerar um nome de arquivo relevante com base no conte√∫do do prompt (ex: `relatorio_vendas_q3.pdf`), em vez de usar sempre "relatorio_gerado.docx".

---

#### **Prioridade 4: Robustez e Qualidade de Vida**

**Objetivo:** Tornar o sistema mais robusto e f√°cil de gerenciar.

-   **[ ] 4.1. Tratamento de Erros Espec√≠fico:**
    -   Dentro da tarefa de IA, adicionar blocos `try...except` espec√≠ficos para falhas comuns (ex: API do Gemini indispon√≠vel, arquivo em formato inv√°lido, template mal formatado).
    -   Retornar mensagens de erro claras e √∫teis para o usu√°rio no chat.

-   **[ ] 4.2. Roles de Usu√°rio (Admin vs. Usu√°rio Comum):**
    -   Adicionar um campo `role` (ex: "admin", "user") na cole√ß√£o `users`.
    -   Modificar o endpoint de upload de templates (`POST /api/templates/upload`) para que apenas usu√°rios com a role "admin" possam acess√°-lo.
    -   Criar endpoints de administra√ß√£o para gerenciar usu√°rios e templates.