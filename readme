# Projeto Agente de IA - Backend

Este √© o reposit√≥rio do backend para o projeto Agente de IA. A aplica√ß√£o √© constru√≠da com Flask e utiliza o MongoDB como banco de dados, Celery para processamento ass√≠ncrono e a API do Google Gemini para as funcionalidades de intelig√™ncia artificial.

## Pr√©-requisitos

Antes de come√ßar, garanta que voc√™ tenha os seguintes softwares instalados em sua m√°quina:

- **Python** (vers√£o 3.10 ou superior)
- **Pip** (gerenciador de pacotes do Python)
- **Git** (para clonar o reposit√≥rio)
- **MongoDB** (uma inst√¢ncia local ou uma conta no [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) para obter a string de conex√£o)
- **Redis** (necess√°rio para o Celery. A forma mais f√°cil de instalar localmente √© via [Docker](https://www.docker.com/))

## ‚öôÔ∏è Instala√ß√£o e Configura√ß√£o

Siga os passos abaixo para configurar o ambiente de desenvolvimento local.

### 1. Clonar o Reposit√≥rio

Abra seu terminal e clone o projeto:

```bash
git clone https://sua-url-do-repositorio.git
cd projeto-agente-ia
```
2. Criar e Ativar o Ambiente Virtual

√â uma boa pr√°tica isolar as depend√™ncias do projeto em um ambiente virtual.

Para macOS / Linux:
```bash
python3 -m venv venv
source venv/bin/activate
```
Para Windows:
```bash
python -m venv venv
.\venv\Scripts\activate
```

3. Instalar as Depend√™ncias

Com o ambiente virtual ativado, instale todas as bibliotecas necess√°rias com um √∫nico comando:

```bash
pip install -r requirements.txt
```

4. Configurar as Vari√°veis de Ambiente

Este √© o passo mais importante. As chaves de API e outras configura√ß√µes sens√≠veis s√£o gerenciadas atrav√©s de um arquivo .env.

a. Crie um arquivo chamado .env na raiz do projeto.

b. Copie o conte√∫do abaixo para dentro do seu arquivo .env e preencha com suas pr√≥prias chaves e configura√ß√µes:

# Arquivo: .env
# Preencha com suas pr√≥prias chaves e configura√ß√µes
```python
# Configura√ß√£o da Aplica√ß√£o Flask
FLASK_ENV=development
SECRET_KEY='coloque-aqui-uma-chave-secreta-bem-longa-e-aleatoria'

# Conex√£o com o Banco de Dados MongoDB
MONGO_URI='sua-string-de-conexao-do-mongodb-aqui'

# Conex√£o com o Broker de Mensagens para Celery
REDIS_URL='redis://localhost:6379/0'

# Chave da API do Google Gemini
GOOGLE_API_KEY='sua-chave-da-api-do-google-aqui'
```

üö® IMPORTANTE: O arquivo .env cont√©m informa√ß√µes sens√≠veis. Ele j√° est√° inclu√≠do no .gitignore e NUNCA deve ser enviado para o reposit√≥rio no GitHub.

‚ñ∂Ô∏è Executando a Aplica√ß√£o

Para rodar o projeto, voc√™ precisar√° de dois terminais abertos, ambos com o ambiente virtual ativado.

1. Iniciar o Servidor Flask

No primeiro terminal, inicie a aplica√ß√£o web:

```bash
python run.py
```

O servidor estar√° dispon√≠vel em http://127.0.0.1:5000. Voc√™ pode testar se ele est√° funcionando acessando http://127.0.0.1:5000/health no seu navegador.

2. Iniciar o Worker do Celery

As tarefas de IA s√£o processadas em segundo plano. Para isso, precisamos de um "worker" do Celery escutando por novas tarefas.

No segundo terminal, execute o seguinte comando:

# NOTA: Este comando ser√° finalizado quando a estrutura do Celery for implementada
```bash
celery -A sua_instancia_celery_aqui worker --loglevel=info
```

(Nota: O comando exato do Celery ser√° definido quando a Se√ß√£o 4 for implementada, mas a estrutura ser√° essa.)

```
üìÇ Estrutura do Projeto
/projeto-agente-ia/
‚îú‚îÄ‚îÄ .env                  # Armazena as vari√°veis de ambiente (secreto)
‚îú‚îÄ‚îÄ requirements.txt      # Lista de depend√™ncias Python
‚îú‚îÄ‚îÄ run.py                # Ponto de entrada para iniciar a aplica√ß√£o
‚îî‚îÄ‚îÄ /src/
    ‚îú‚îÄ‚îÄ __init__.py         # Application Factory (cria a app Flask)
    ‚îú‚îÄ‚îÄ config.py           # Carrega as configura√ß√µes do .env
    ‚îú‚îÄ‚îÄ /api/               # M√≥dulos de endpoints (Blueprints)
    ‚îú‚îÄ‚îÄ /db/                # L√≥gica de conex√£o com o banco de dados
    ‚îî‚îÄ‚îÄ /tasks/             # Tarefas ass√≠ncronas para o Celery (IA, etc.)
```

# Projeto Agente de IA - Checklist de Desenvolvimento (Backend)

Este documento rastreia o progresso do desenvolvimento do backend. Marque as caixas conforme as tarefas forem conclu√≠das.

---

### Se√ß√£o 1: Funda√ß√£o do Projeto (Setup Inicial)

**Objetivo:** Criar um esqueleto de aplica√ß√£o Flask funcional, organizado e pronto para escalar.

- [x] **1.1. Estrutura de Pastas:** Estrutura base com `src`, `api`, `db`, `tasks` est√° criada.
- [x] **1.2. Gerenciamento de Depend√™ncias:** Arquivo `requirements.txt` foi atualizado para remover Celery/Redis e usar Flask.
- [x] **1.3. Configura√ß√£o de Ambiente:** Arquivo `.env` foi criado e o `.gitignore` est√° configurado para ignor√°-lo.
- [x] **1.4. Application Factory:** A fun√ß√£o `create_app` em `src/__init__.py` monta a aplica√ß√£o Flask corretamente, sem a configura√ß√£o do Celery.
- [x] **1.5. Conex√£o com Banco de Dados:** A aplica√ß√£o conecta-se com sucesso ao MongoDB na inicializa√ß√£o.
- [x] **1.6. Valida√ß√£o do Setup:** O endpoint `GET /health` est√° funcionando e retorna uma mensagem de sucesso.

---

### Se√ß√£o 2: M√≥dulo de Autentica√ß√£o e Usu√°rios

**Objetivo:** Implementar um sistema seguro de registro e login usando JWT.

- [x] **2.1. Modelo de Dados:** A cole√ß√£o `users` est√° sendo utilizada para armazenar `username` e `hashed_password`.
- [x] **2.2. Fun√ß√µes de Criptografia:** Fun√ß√µes para criar e verificar hashes de senha com `passlib` est√£o implementadas.
- [x] **2.3. Endpoint de Registro (`POST /api/auth/register`):**
    - [x] Recebe `username` e `password`.
    - [x] Verifica se o usu√°rio j√° existe.
    - [x] Salva o novo usu√°rio com a senha criptografada.
    - [x] Retorna status `201 Created` em caso de sucesso.
- [x] **2.4. Endpoint de Login (`POST /api/auth/login`):**
    - [x] Recebe `username` e `password`.
    - [x] Valida as credenciais contra os dados no banco.
    - [x] Gera e retorna um `access_token` JWT em caso de sucesso.
- [x] **2.5. Endpoint de Perfil (`GET /api/auth/profile`):**
    - [x] A rota est√° protegida e requer um token JWT v√°lido.
    - [x] Extrai a identidade do usu√°rio a partir do token.
    - [x] Retorna os dados do usu√°rio logado (sem a senha).

---

### Se√ß√£o 3: Gerenciamento de Arquivos com GridFS

**Objetivo:** Criar endpoints para upload e download de arquivos grandes.

- [x] **3.1. Modelos de Dados:** As cole√ß√µes `templates` e `documents` s√£o utilizadas para armazenar os metadados dos arquivos.
- [x] **3.2. Endpoint de Upload de Template (`POST /api/templates/upload`):** Rota implementada e funcional.
- [x] **3.3. Endpoint de Upload de Documento (`POST /api/documents/upload`):** Rota implementada e funcional.
- [x] **3.4. Endpoint de Download (`GET /api/files/<gridfs_file_id>`):**
    - [x] A rota est√° protegida.
    - [x] Verifica a permiss√£o do usu√°rio para acessar o arquivo.
    - [x] Busca o arquivo no GridFS e o retorna para download.

---

### Se√ß√£o 4: M√≥dulo Conversacional com Arquitetura CrewAI

**Objetivo:** Orquestrar uma equipe de agentes de IA para processar solicita√ß√µes de forma modular e robusta.

- [x] **4.1. Defini√ß√£o das Ferramentas (`tools.py`):**
    - [x] Ferramenta `FileReaderTool` para ler arquivos do GridFS est√° criada.
    - [x] Ferramenta `TemplateFillerTool` para preencher templates est√° criada.
- [x] **4.2. Defini√ß√£o dos Agentes (`agents.py`):**
    - [x] `agente_roteador` (analista/planejador) est√° definido.
    - [x] `agente_executor_de_arquivos` (especialista em ferramentas) est√° definido.
- [x] **4.3. Orquestra√ß√£o da Crew (`ia_processor.py`):**
    - [x] A fun√ß√£o `processar_solicitacao_ia` foi refatorada para montar e executar uma `Crew`.
    - [x] As tarefas (`Task`) para an√°lise e execu√ß√£o est√£o definidas.
- [x] **4.4. Valida√ß√£o do Fluxo de Decis√£o:**
    - [x] Testar se o `agente_roteador` consegue interpretar um prompt e delegar a tarefa correta.
    - [x] Testar se o `agente_executor` consegue usar a `FileReaderTool` com sucesso.
    - [x] Testar se o `agente_executor` consegue usar a `TemplateFillerTool` com sucesso.
- [x] **4.5. Processamento do Resultado Final:**
    - [x] A resposta final da `Crew` √© corretamente interpretada.
    - [x] A mensagem do assistente e os links para os documentos gerados s√£o salvos corretamente no MongoDB.
    
---

### **Pr√≥ximos Passos para o Desenvolvimento do Backend**

#### **üéØ Foco Imediato: Tornar a IA Mais Inteligente e Flex√≠vel**

**Objetivo:** Aumentar drasticamente a capacidade da IA de entender e executar uma gama maior de tarefas relacionadas a documentos.

*   **[x] 1. Implementar um "Agente Conversador" para Respostas Diretas:**
    *   **Tarefa:** Criar um novo agente, `agente_conversador`, que n√£o possui ferramentas.
    *   **L√≥gica:** Modificar o `agente_roteador` para que ele possa delegar a tarefa a este novo agente se a inten√ß√£o do usu√°rio for apenas uma pergunta geral. Isso evita que a Crew tente usar ferramentas desnecessariamente.

*   **[x] 2. Criar Ferramenta de Gera√ß√£o de Documentos Simples:**
    *   **Tarefa:** Desenvolver uma nova `SimpleDocumentGeneratorTool` em `tools.py`.
    *   **Par√¢metros:** `content` (o texto a ser inserido) e `file_format` ("docx", "pdf", etc.).
    *   **A√ß√£o:** A ferramenta chamar√° a fun√ß√£o `criar_docx_stream` ou `criar_pdf_stream` correspondente.
    *   **Integra√ß√£o:** Adicionar esta ferramenta ao `agente_executor_de_arquivos` e ensinar o `agente_roteador` a us√°-la.

*   **[x] 3. Habilitar a Extra√ß√£o de Contexto de Arquivos Anexados:**
    *   **Tarefa:** Refinar a `backstory` e a `goal` do `agente_roteador`.
    *   **L√≥gica:** Instru√≠-lo a, quando o usu√°rio pedir para preencher um template e anexar um arquivo, primeiro usar a `FileReaderTool` para extrair o conte√∫do do anexo e, em seguida, usar esse conte√∫do para construir o dicion√°rio de `context` para a `TemplateFillerTool`. Isso pode exigir um passo intermedi√°rio ou um agente adicional.

#### **üéØ Foco a M√©dio Prazo: Melhorar a Gest√£o de Arquivos e a Usabilidade**

**Objetivo:** Dar ao usu√°rio mais controle sobre seus dados e tornar o sistema mais intuitivo.

*   **[x] 4. Implementar Nomea√ß√£o de Arquivos Inteligente:**
    *   **Tarefa:** Adicionar um novo par√¢metro `output_filename` √† `TemplateFillerTool` e √† `SimpleDocumentGeneratorTool`.
    *   **L√≥gica:** Ensinar o `agente_roteador` a extrair um nome de arquivo apropriado do prompt do usu√°rio ou a criar um com base no contexto (ex: "proposta_cliente_x.docx"). Se nenhum nome for sugerido, um nome padr√£o ser√° usado.

*   **[ ] 5. Desenvolver Endpoints para Gerenciamento de Dados:**
    *   **Tarefa:** Criar novas rotas na API para funcionalidades de CRUD (Criar, Ler, Atualizar, Deletar).
        *   `GET /api/documents`: Listar todos os metadados dos documentos do usu√°rio logado.
        *   `DELETE /api/documents/<document_id>`: Excluir um documento (e seu arquivo correspondente no GridFS).
        *   `DELETE /api/chat/messages/<message_id>`: Excluir uma mensagem espec√≠fica de uma conversa.
        *   `DELETE /api/chat/conversations/<conversation_id>`: Excluir uma conversa inteira e todas as suas mensagens.

*   **[ ] 6. (Opcional) Adicionar Suporte a Anexos M√∫ltiplos:**
    *   **Tarefa:** Modificar a rota `POST /conversations` para aceitar uma lista de `input_document_ids` em vez de um √∫nico ID.
    *   **L√≥gica:** Adaptar a l√≥gica de enriquecimento de prompt no `ia_processor.py` para ler e concatenar o conte√∫do de m√∫ltiplos arquivos.

---

#### **üî≠ Foco a Longo Prazo: Robustez e Polimento**

**Objetivo:** Preparar a aplica√ß√£o para um ambiente mais cr√≠tico, focando em confiabilidade e experi√™ncia do usu√°rio.

*   **[ ] 7. Implementar Tratamento de Erros Guiado por IA:**
    *   **Tarefa:** Criar um "Agente de An√°lise de Erros".
    *   **L√≥gica:** Dentro do bloco `except` principal do `processar_solicitacao_ia`, em vez de apenas registrar um erro gen√©rico, passar a mensagem de erro t√©cnica para este novo agente.
    *   **Goal do Agente:** A meta do agente ser√° traduzir o erro t√©cnico (ex: "Template 'x' not found") em uma sugest√£o amig√°vel e √∫til para o usu√°rio (ex: "N√£o encontrei esse template. Voc√™ quis dizer 'y'? Os templates dispon√≠veis s√£o...").

*   **[ ] 8. Reintroduzir o Processamento Ass√≠ncrono (Celery + Redis):**
    *   **Tarefa:** Reverter as simplifica√ß√µes que fizemos. Reintroduzir o Celery, configurar o Redis e transformar a chamada `processar_solicitacao_ia` de volta em uma chamada `.delay()`.
    *   **Frontend:** Ser√° necess√°rio implementar um mecanismo de *polling* ou *WebSockets* para que a interface saiba quando a tarefa foi conclu√≠da.